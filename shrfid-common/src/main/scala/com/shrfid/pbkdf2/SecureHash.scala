package com.shrfid.pbkdf2

/**
  * Created by jiejin on 4/05/2016.
  */


import java.nio.charset.StandardCharsets.UTF_8
import java.util.Base64

import scala.util.Try

/**
  * Implements functionality to create and validate password hashes using [[PBKDF2]]
  */
object SecureHash {

  import internals._

  /**
    * Creates a hashed password using [[PBKDF2]]
    *
    * this function output a string in the modified MCF format :
    *
    * p0\$params\$salt\$key
    *
    * - p0 : version 0 of the format
    *
    * - params: 8 digit hexadecimal representation of the number of iterations concatenated with the algo name
    *
    * - salt : Base64 encoded salt
    *
    * - key : Base64 encoded derived key
    *
    * Example :
    *
    * p0\$00004e20HmacSHA256\$mOCtN/Scjry0uIALe4bCCrL9eL8aWEA/\$hDxtqCnBF1MS5qIOxHeDAZ23QEmqdL7796I0pVJ2yvQ
    *
    * @param password   the password to hash
    * @param iterations the number of encryption iterations, default to 20000
    * @param dkLength   derived-key length, default to 32
    * @param cryptoAlgo HMAC+SHA512 is the default as HMAC+SHA1 is now considered weak
    * @param saltLength length of the salt, default to 24
    */
  def createHash(password: String, iterations: Int = 20000,
                 dkLength: Int = 32, cryptoAlgo: String = "HmacSHA512", saltLength: Int = 24): String = {


    val salt = randomAlphanumericString(saltLength)

    val key = PBKDF2(password.getBytes(UTF_8), salt.getBytes(UTF_8), iterations, dkLength, cryptoAlgo)
    encode(salt.getBytes(UTF_8), key, iterations, cryptoAlgo)
  }

  def randomString(alphabet: String)(n: Int): String = {
    val random = new scala.util.Random(new java.security.SecureRandom())
    Stream.continually(random.nextInt(alphabet.size)).map(alphabet).take(n).mkString
  }

  // Generate a random alphabnumeric string of length n
  def randomAlphanumericString(n: Int) =
    randomString("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")(n)

  /**
    * Tests two byte arrays for value equality in constant time.
    *
    * @note This function leaks information about the length of each byte array as well as
    *       whether the two byte arrays have the same length.
    * @see [[http://codahale.com/a-lesson-in-timing-attacks]]
    */
  private[this] def secure_==(a1: Array[Byte], a2: Array[Byte]): Boolean =
    a1.length == a2.length && a1.zip(a2).foldLeft(0) { case (r, (x1, x2)) => r | x1 ^ x2 } == 0

  /**
    * Validate a password against a password hash
    *
    * @param password       the password to validate
    * @param hashedPassword the password hash. This should be in the same format as generated by [[SecureHash.createHash]]
    * @return true is the password is valid
    */
  def validatePassword(password: String, hashedPassword: String): Boolean = decode(hashedPassword) match {
    case Some(Decoded(_, iterations, algo, salt, key)) =>
      val hash = PBKDF2(password.getBytes(UTF_8), salt, iterations, key.length, algo)
      secure_==(key, hash)
    case _ => false
  }

  private[pbkdf2] object internals {
    def encode(salt: Array[Byte], key: Array[Byte], iterations: Int, algo: String): String = {
      val iters = iterations.toString
      // use hash name compatible with PassLib (https://pythonhosted.org/passlib/index.html)
      val compAlgo = javaAlgoToPassLibAlgo.getOrElse(algo, algo)
      s"pbkdf2_$compAlgo$$$iters$$${new java.lang.String(salt)}$$${b64Encoder(key)}"
    }

    case class Decoded(version: String, iterations: Int, algo: String, salt: Array[Byte], key: Array[Byte])

    def decode(s: String): Option[Decoded] = Try {
      s match {
        case rx(a, i, s, h) => Some(Decoded("pbkdf2", i.toInt, passLibAlgoToJava.getOrElse(a, a), s.getBytes(UTF_8), b64Decoder(h)))
        case _ => None
      }
    }.toOption.flatten

    private[pbkdf2] val javaAlgoToPassLibAlgo = Map("HmacSHA1" -> "sha1", "HmacSHA256" -> "sha256", "HmacSHA512" -> "sha512")
    private[pbkdf2] val passLibAlgoToJava = javaAlgoToPassLibAlgo.map(_.swap)
    private[this] val rx = "pbkdf2_([^\\$]+)\\$(\\d+)\\$([^\\$]*)\\$([^\\$]*)".r

    private[this] def b64Decoder(s: String) =
      Base64.getDecoder.decode(s)

    private[this] def b64Encoder(ba: Array[Byte]) =
      Base64.getEncoder.encodeToString(ba)
  }

}
